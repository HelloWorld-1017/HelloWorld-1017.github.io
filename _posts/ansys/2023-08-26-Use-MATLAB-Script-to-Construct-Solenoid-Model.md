---
title: Use MATLAB Script to Construct Solenoid Model in Ansys Electronics Desktop
categories:
 - MATLAB
 - Finite Element Simulation
 - Physics
tags:
 - Electromagnetism
 - MATLAB External Language Interfaces
 - VBScript
date: 2023-08-26 06:10:11 +0800
last_modified_at: 2024-07-17 15:02:48 +0800
---

# Introduction

About two months ago, I studied a simple-but-complete FEM example from Ansys Electronics Desktop (AEDT) about how to use AEDT to simulate a solenoid model and obtain the corresponding simulation results, mainly including magnetic flux and electromagnetic force. This example helped me to understand the basic operation in AEDT software and push on my personal research. However, in the past period of time, I spent most time and energy to learn English for IELTS examination, thereby forgetting some details of this example when I looking back right now. So I would write this blog to put these contents together. 

This FEM example is called *Getting Started with Maxwell: A 2D Magnetostatic Solenoid Problem* [1]. The introduction in PDF version is available in `Help` tab if you have installed AEDT and inserted a Maxwell 2D (or 3D) Design (in `Project` Tab):

![image-20230826204855555](https://github.com/HelloWorld-1017/blog-images/blob/main/migration/imgpersonal/image-20230826204855555.png?raw=true)

This 92-page introduction is rather detailed and freshman-friendly, illustrating how to build and analyse Solenoid model from scratch. Almost everyone could get the same results if follow this tech booklet step by step. So, this blog is not intent to repeat or copy its contents, but try to cope with an issue associated with efficiency: How to construct and simulate solenoid model in scripting way (specifically using MATLAB) ?

To begin with, the AEDT supported scripting, and the relative documentation (called *Maxwell Scripting Guide*) could also be found in `Help` tab as shown in the above figure. This documentation gives the information about how to build an FEM model using two alternative scripting ways, by either **VBscript** or **IronPython**. The usage of each function looks the same no mater which scripting language we choose as I reckon they are both belonging to the object-oriented programming. However, my favourite scripting software is MATLAB, so I spent some time to find an approach to use MATLAB to realise my objective. Luckily, it works, by creating COM server [2] and then calling VBscript object in MATLAB.

```matlab
% Define the activex scripting engine
obj.oAnsoftApp = actxserver('Ansoft.ElectronicsDesktop.2021.1'); % NB: the AEDT version in compurter

% Open the Ansys EDT
obj.oDesktop = obj.oAnsoftApp.GetAppDesktop();
```

On the other hand, the AEDT provides the further convenience: it supports recording user’s operation and converting it to VBscript version (`Tools` Tab -> `Record Script To File...`):

![image-20230827061944954](https://github.com/HelloWorld-1017/blog-images/blob/main/migration/imgpersonal/image-20230827061944954.png?raw=true)

So, what I should do next is convert VBscript code to the recognisable form MATLAB could identify. 

Although this process is kind of tedious, especially when there are loads of operations, it is basically worthy cause the final script does liberate users from repetitive mouse-click and keyboard-input operations. Besides, we could easily and accurately modify the parameters of components and thereby observe different results, which is my original intention.

What’s more, after getting the whole process-oriented script, I converted it to the object-oriented version, i.e. I constructed an MATLAB class called `Solenoid`, which makes the whole workflow more clear and easier to facilitate management.

<br>

# Overview

The following overview is organised base on TOC of the introduction PDF, and alongside with some important information: 

1. **Setting Up the Design**

   1. **Specify a Solution Type**: Solution type is ‘Magnetostatic’; Geometry Mode is ‘Cylindrical about Z’.
   2. **Set the Drawing Units**: the unit in this model is in (inches, 1 in = 25.4 mm).

2. **Creating the Geometric Model & Assigning Materials**

   1. **Create the Plugnut**: user-defined material ‘SS430’, defined by nonlinear B-H curve.

   2. **Create the Core**: user-defined material ‘Neo35’, which is a permanently magnetic material and defined by `Rel.Permeability(Mu) = 1.05` and `Mag.Retentivity(Br) = 1.25` (alternatively `Mag.Coercivity Magnitude(Hc) = -947350.85`). In addition, the direction of magnetisation (i.e. magnet orientation) of Core should be assigned using a new relative coordinate system. 

   3. **Create the Coil**: built-in material ‘copper’.

   4. **Create the Yoke and Bonnet**: user-defined material ‘ColdRolledSteel’, defined by nonlinear B-H curve.

   5. **Create the Background (Problem Region)**: default material ‘Vacuum’.

      <img src="https://github.com/HelloWorld-1017/blog-images/blob/main/migration/DeLLLaptop/image-20230910151203043.png?raw=true" alt="image-20230910151203043" style="zoom:50%;" />

      ```matlab
      clc,clear,close all
      
      % B-H curve for material "Cold Rolled Steel"
      H1 = [0.0,1080,1480,2090,3120,5160,9930,1.55e4,2.50e4,3.50e4];
      B1 = [0.0,0.858,1.06,1.26,1.44,1.61,1.77,1.86,1.88,1.90];
      
      % B-H curve for material "SS430"
      H2 = [0.0,143,180,219,259,298,338,378,438,517,597,716,955,1590,3980,6370,1.19e4,2.39e4,3.98e4];
      B2 = [0.0,0.125,0.206,0.394,0.589,0.743,0.853,0.932,1.01,1.08,1.11,1.16,1.20,1.27,1.37,1.43,1.49,1.55,1.59];
      
      figure
      hold(gca,"on"),grid(gca,"on"),box(gca,"on")
      
      plot(H1,B1,"LineWidth",1.5,"Color",[7,84,213]/255,"Marker","o","DisplayName","Cold Rolled Steel")
      plot(H2,B2,"LineWidth",1.5,"Color",[249,82,107]/255,"Marker","square","DisplayName","SS430")
      xlabel("H (A/m)")
      ylabel("B (T)")
      legend("Location","southeast");
      ```

3. **Setting Up the Solenoid Model**

   1. **Set Up Boundaries**: “The structure is a magnetically isolated system”, therefore, a Balloon Boundary should be assigned to outside edges of the background object, which means “the structure is infinitely far away from all other electromagnetic sources”. Note that “The edge along the Z axis will not be assigned since this is the axis of rotation for this Cylindrical about Z problem.”
   2. **Set up Current Sources**: assigning a 10,000-amperes current source to the Coil object, which means “the coil has 10,000 turns of wire, and one ampere flows through each turn, the net source current is 10,000 amperes”. And the `Ref.Direction` is set to `Positive`, indicating “current flowing in the positive PHI direction, in this case, into the screen”. 
   3. **Set Up Force Computation**: “One of your goals for this problem is to determine the force acting on the Core object of the solenoid. To find the force on this object, you must select it and assign the force parameter. The force (in newtons) acting on the core will then be computed during the solution process.” 
   4. **Set Up Inductance Computation**: “In addition to the force on the core, the coil inductance is of interest.”

4. **Generate a Solution**

   This part is intent to set and generate a magnetostatic solution.

   “Generate the magnetostatic solution. The axisymmetric magnetostatic solver calculates the magnetic vector potential, $\mathrm{\boldsymbol{A}}_{\Phi}$, at all points in the problem region. From this, the magnetic field, $\mathrm{\boldsymbol{H}}$, and magnetic flux density, $\mathrm{\boldsymbol{B}}$, can be determined.” 

   The Adaptive Analysis settings include `Maximum Number of Passes` (10), `Percent Error` (1%); the Mesh Mesh Refinement Criteria Settings include `Refinement Per Pass` (30%), `Minimum Number of Passes` (2), and `Minimum Converged Passes` (1); the Solver Residual setting is `Nonlinear Residual` (0.0001).

5. **Analysing the Solution**

   The solution would be analysed from perspective of Force Solution and Magnetic Filed visualisation.

6. **Adding Variables to the Solenoid Model & Generating a Parametric Solution** 

   This part is to a geometric variable which represents the gap distance between solenoid’s Core and Plugnut, and “By varying the distance (0.0 to 0.5 inches) between these objects, you can model the solenoid’s behaviour over a range of core positions.” At last, we could obtain the magnetic flux matrix and electromagnetic force as a function of distance and current. This is what I interest most and also the key point of analysis of results generated by the following script. 

<br>

# Object-oriented MATLAB Script to Construct Solenoid Model in AEDT

`Solenoid` Class: 

```matlab
classdef Solenoid < handle
    properties
        oAnsoftApp
        oDesktop
        oProject
        odesign
        oDesign
        oEditor
        oDefinitionManager
        oModule
        data
        FolderName
        LengthUnit = 'in';
        plugnut
        core
        coil
        yoke
        bonnet
        bkgd
        turns = 10000;
        ampere = 1;
        MaxGap = 0.2;
    end

    methods
        function obj = Solenoid()
            % Create a folder
            ExistedFolders = dir(fullfile(pwd,"case-*"));
            if ~isempty(ExistedFolders)
                ExistedFolders = ExistedFolders(end).name;
                maxIdx = str2double(ExistedFolders(end-3:end));
                idx = maxIdx+1;
            else
                idx = 1;
            end
            obj.FolderName = "case-" + sprintf("%04s",num2str(idx));
            mkdir(obj.FolderName);

            % Define components
            % Define plugnut
            obj.plugnut.XStart = 0;
            obj.plugnut.ZStart = -0.2;
            obj.plugnut.Width = -1;
            obj.plugnut.Height = 0.3;

            % Define core
            obj.core.x = [0.1,0.1,0.2,0.2,0.3,0.3,0.1];
            obj.core.z = [1.2,-0.15,-0.15,-0.1,-0.1,1.2,1.2];

            % Define coil
            obj.coil.XStart = 0.375;
            obj.coil.ZStart = 0.7;
            obj.coil.Width = -1.5;
            obj.coil.Height = 0.4;

            % Define yoke
            obj.yoke.x = [0.35,1.1,1.1,0.35,0.35,1.05,1.05,0.35,0.35];
            obj.yoke.z = [-1.05,-1.05,0.8,0.8,0.75,0.75,-1,-1,-1.05];

            % Define bonnet
            obj.bonnet.x = [0.35,0.5,0.5,0.425,0.425,0.35,0.35];
            obj.bonnet.z = [0.8,0.8,0.95,0.95,1.177,1.177,0.8];

            % Define background
            obj.bkgd.XStart = 0;
            obj.bkgd.ZStart = -2;
            obj.bkgd.Width = 4;
            obj.bkgd.Height = 2;

            obj.plotModelSchematics();
        end

        function plotModelSchematics(obj)
            figure,axes
            hold(gca,'on'),box(gca,'on'),grid(gca,'on'),axis(gca,'equal')
            xlim([-3,3]),ylim([-3,3])

            % Plot plugnut
            [plugnut_x,plugnut_z] = helper_Rectangle(obj.plugnut.XStart,obj.plugnut.ZStart,obj.plugnut.Height,obj.plugnut.Width);
            patch(plugnut_x,plugnut_z,[0 0 255]/255,'DisplayName','Plugnut')

            % Plot Core
            patch(obj.core.x,obj.core.z,[0 255 0]/255,'DisplayName','Core');

            % Plot Coil
            [coil_x,coil_z] = helper_Rectangle(obj.coil.XStart,obj.coil.ZStart,obj.coil.Height,obj.coil.Width);
            patch(coil_x,coil_z,[255 0 0]/255,'DisplayName','Coil')

            % Plot Yoke
            patch(obj.yoke.x,obj.yoke.z,[255 0 255]/255,'DisplayName','Yoke');

            % Plot Bonnet
            patch(obj.bonnet.x,obj.bonnet.z,[255 255 0]/255,'DisplayName','Bonnet');

            % Plot Background
            [bkgd_x,bkgd_z] = helper_Rectangle(obj.bkgd.XStart,obj.bkgd.ZStart,obj.bkgd.Height,obj.bkgd.Width);
            patch(bkgd_x,bkgd_z,[143 175 143]/255,'DisplayName','Background','FaceAlpha',0.1)
            xlabel(sprintf("x-axis (%s)",obj.LengthUnit))
            ylabel(sprintf("z-axis (%s)",obj.LengthUnit))
            legend('Location','northwest')
            exportgraphics(gca,fullfile(obj.FolderName,"ModelSchematic.jpg?raw=true"),"Resolution",600);

            function [x,z] = helper_Rectangle(x,z,height,wdith)
                x = [x,x+height,x+height,x];
                z = [z,z,z+wdith,z+wdith];
            end
        end

        function helperPipeline(obj)
            % Initialize
            obj.initialize();

            % Define materials
            obj.oDefinitionManager = obj.oProject.GetDefinitionManager();
            obj.defineMaterials();

            % Construct components
            obj.definePlugnut();
            obj.defineCore();
            obj.defineCoil();
            obj.defineYoke();
            obj.defineBonnet();
            obj.defineBKGD();

            % Define excitation
            obj.defineExcitation();

            % Set buondary
            obj.defineBoundary();

            % Define computation
            obj.defineComputation();

            % Define solution setup
            obj.defineSolutionSetup();
            obj.oProject.SaveAs(fullfile(pwd,obj.FolderName,"Solenoid.aedt"),true);

            % Define movement and current
            obj.defineMovement();
            obj.defineCurrent();

            % Define solver settings
            solverName = 'ParametricSetup1';
            obj.defineSolver(solverName,[0,0.5,0.05],[0,1500,11]); % 'LIN 0in 0.5in 0.05in', 'LINC 0A 1500A 11'

            % Run simulation
            obj.oModule.SolveSetup(solverName);

            % Export data tables of force, L, and Magflux
            obj.exportReports();

            obj.oProject.Save();
            % obj.oProject.Close();
            % obj.oAnsoftApp.delete();

            % Plot results (force,inductor,Flux)
            obj.plotResults();
        end

        function initialize(obj)
            % Define the activex scripting engine
            obj.oAnsoftApp = actxserver('Ansoft.ElectronicsDesktop.2021.1');

            % Open the Ansys EDT
            obj.oDesktop = obj.oAnsoftApp.GetAppDesktop();

            obj.oDesktop.RestoreWindow(); % Maximize the minimized window

            % Create a new object
            obj.oProject = obj.oDesktop.NewProject();

            % Creat a new Magnetostatic
            obj.oProject.InsertDesign('Maxwell 2D','Solenoid','Magnetostatic',''); % Create design and Magnetostatic

            % Set the design as active
            obj.oDesign = obj.oProject.SetActiveDesign('Solenoid');

            % Set 2D design in "Cylindrical about Z" geometry mode
            obj.oDesign.invoke('SetSolutionType','Magnetostatic','about Z');
            % obj.oDesign.GetGeometryMode() % Verify geometry mode

            obj.oEditor = obj.oDesign.SetActiveEditor("3D Modeler");
            % Set units
            obj.oEditor.invoke('SetModelUnits',...
                {'NAME:Units Parameter','Units:=','in','Rescale:=',false});
            % obj.oEditor.GetModelUnits() % Verify unit
        end

        function defineMaterials(obj)
            % Define material: ColdRolledSteel
            obj.oDefinitionManager.invoke('AddMaterial', ...
                {'NAME:ColdRolledSteel', ...
                'CoordinateSystemType:=','Cartesian', ...
                'BulkOrSurfaceType:=',1, ...
                {'NAME:PhysicsTypes', 'set:=',{'Electromagnetic'}} ...
                {'NAME:permeability', ...
                'property_type:=','nonlinear', ...
                'BTypeForSingleCurve:=','normal', ...
                'HUnit:=','A_per_meter', ...
                'BUnit:=','tesla', ...
                'IsTemperatureDependent:=',false, ...
                {'NAME:BHCoordinates', ...
                {'NAME:DimUnits','',''}, ...
                {'NAME:Point',0,0}, ...
                {'NAME:Point',1080,0.858},...
                {'NAME:Point',1480,1.06}, ...
                {'NAME:Point',2090,1.26}, ...
                {'NAME:Point',3120,1.44}, ...
                {'NAME:Point',5160,1.61}, ...
                {'NAME:Point',9930,1.77}, ...
                {'NAME:Point',15500,1.86}, ...
                {'NAME:Point',25000,1.88}, ...
                {'NAME:Point',35000,1.9}}, ...
                {'NAME:Temperatures'}}, ...
                {'NAME:magnetic_coercivity', ...
                'property_type:=','VectorProperty', ...
                'Magnitude:=','0A_per_meter', ...
                'DirComp1:=','1', ...
                'DirComp2:=','0', ...
                'DirComp3:=','0'}});

            % Define Neo35
            obj.oDefinitionManager.invoke('AddMaterial', ...
                {'NAME:Neo35', ...
                'CoordinateSystemType:=','Cartesian',...
                'BulkOrSurfaceType:=',1, ...
                {'NAME:PhysicsTypes','set:=', ...
                {'Electromagnetic'}}, ...
                'permeability:=','1.05', ...
                {'NAME:magnetic_coercivity', ...
                'property_type:=','VectorProperty', ...
                'Magnitude:=','-947350.851737472A_per_meter', ...
                'DirComp1:=','1', ...
                'DirComp2:=','0', ...
                'DirComp3:=','0'}});
            % Create relative CS for Neo35
            obj.oEditor.invoke('CreateRelativeCS', ...
                {'NAME:RelativeCSParameters', ...
                'Mode:=','Axis/Position', ...
                'OriginX:=','0in', ...
                'OriginY:=','0in', ...
                'OriginZ:=','0in', ...
                'XAxisXvec:=','0in', ...
                'XAxisYvec:=','0in', ...
                'XAxisZvec:=','-1.7in', ...
                'YAxisXvec:=','0in', ...
                'YAxisYvec:=','1in', ...
                'YAxisZvec:=','0in'}, ...
                {'NAME:Attributes', ...
                'Name:=','RelativeCS1'});
            % Return to Global coordinate system
            obj.oEditor.invoke('SetWCS',{'NAME:SetWCS Parameter', ...
                'Working Coordinate System:=','Global', ...
                'RegionDepCSOk:=',false});

            % Define SS430
            obj.oDefinitionManager.invoke('AddMaterial', ...
                {'NAME:SS430', ...
                'CoordinateSystemType:=','Cartesian', ...
                'BulkOrSurfaceType:=',1, ...
                {'NAME:PhysicsTypes', 'set:=',{'Electromagnetic'}} ...
                {'NAME:permeability', ...
                'property_type:=','nonlinear', ...
                'BTypeForSingleCurve:=','normal', ...
                'HUnit:=','A_per_meter', ...
                'BUnit:=','tesla', ...
                'IsTemperatureDependent:=',false, ...
                {'NAME:BHCoordinates', ...
                {'NAME:DimUnits','',''}, ...
                {'NAME:Point',0,0}, ...
                {'NAME:Point',143,0.125},...
                {'NAME:Point',180,0.206},...
                {'NAME:Point',219,0.394}, ...
                {'NAME:Point',259,0.589}, ...
                {'NAME:Point',298,0.743}, ...
                {'NAME:Point',338,0.853}, ...
                {'NAME:Point',378,0.932}, ...
                {'NAME:Point',438,1.01}, ...
                {'NAME:Point',517,1.08}, ...
                {'NAME:Point',597,1.11}, ...
                {'NAME:Point',716,1.16}, ...
                {'NAME:Point',955,1.2}, ...
                {'NAME:Point',1590,1.27}, ...
                {'NAME:Point',3980,1.37}, ...
                {'NAME:Point',6370,1.43}, ...
                {'NAME:Point',11900,1.49}, ...
                {'NAME:Point',23900,1.55}, ...
                {'NAME:Point',39800,1.59}}, ...
                {'NAME:Temperatures'}}, ...
                {'NAME:magnetic_coercivity', ...
                'property_type:=','VectorProperty', ...
                'Magnitude:=','0A_per_meter', ...
                'DirComp1:=','1', ...
                'DirComp2:=','0', ...
                'DirComp3:=','0'}});
        end

        function defineExcitation(obj)
            % Assign Current excitation
            obj.oModule = obj.oDesign.GetModule("BoundarySetup");
            obj.oModule.invoke('AssignCurrent', ...
                {'NAME:Current1', ...
                'Objects:=',{'Coil'}, ...
                'Current:=',[num2str(obj.turns*obj.ampere),'A'], ...
                'IsPositive:=',true});
        end

        function defineBoundary(obj)
            % Assing balloon boundary
            obj.oModule = obj.oDesign.GetModule("BoundarySetup");
            obj.oModule.invoke('AssignBalloon', ...
                {'NAME:Balloon1','Edges:=',{90,89,88}});
        end

        function defineComputation(obj)
            % Set up force computation
            obj.oModule = obj.oDesign.GetModule("MaxwellParameterSetup");
            obj.oModule.invoke('AssignForce', ...
                {'NAME:Force1', ...
                'Reference CS:=','Global', ...
                'Objects:=',{'Core'}});

            % Set up inductance computation
            obj.oModule.invoke('AssignMatrix', ...
                {'NAME:Matrix1', ...
                {'NAME:MatrixEntry', ...
                {'NAME:MatrixEntry', ...
                'Source:=','Current1', ...
                'NumberOfTurns:=','1', ...
                'ReturnPath:=','infinite'}}, ...
                {'NAME:MatrixGroup'}});
        end

        function defineSolutionSetup(obj)
            % Add solution setup
            obj.oModule = obj.oDesign.GetModule("AnalysisSetup");
            obj.oModule.invoke('InsertSetup', ...
                'Magnetostatic', ...
                {'NAME:Setup1', ...
                'Enabled:=',true, ...
                {'NAME:MeshLink', ...
                'ImportMesh:=',false}, ...
                'MaximumPasses:=',10, ...
                'MinimumPasses:=',2, ...
                'MinimumConvergedPasses:=',1, ...
                'PercentRefinement:=',30, ...
                'SolveFieldOnly:=',false,...
                'PercentError:=',1, ...
                'SolveMatrixAtLast:=',true, ...
                'UseNonLinearIterNum:=',false, ...
                'CacheSaveKind:=','Delta', ...
                'ConstantDelta:=','0s', ...
                'NonLinearResidual:=',0.0001, ...
                'SmoothBHCurve:=',false, ...
                {'NAME:MuOption', ...
                'MuNonLinearBH:=',true}...
                });
        end

        function defineMovement(obj)
            % Add movement to Core
            obj.oEditor.invoke('Move', ...
                {'NAME:Selections', ...
                'Selections:=','Core', ...
                'NewPartsModelFlag:=','Model'}, ...
                {'NAME:TranslateParameters', ...
                'TranslateVectorX:=','0in', ...
                'TranslateVectorY:=','0in', ...
                'TranslateVectorZ:=',[num2str(obj.MaxGap),obj.LengthUnit]})
            obj.oDesign.invoke('ChangeProperty', ...
                {'NAME:AllTabs', ...
                {'NAME:LocalVariableTab', ...
                {'NAME:PropServers','LocalVariables'}, ...
                {'NAME:NewProps', ...
                {'NAME:deltagap', ...
                'PropType:=','VariableProp', ...
                'UserDef:=',true, ...
                'Value:=','0in'}}}});
            obj.oEditor.invoke('ChangeProperty', ...
                {'NAME:AllTabs', ...
                {'NAME:Geometry3DCmdTab', ...
                {'NAME:PropServers','Core:Move:1'}, ...
                {'NAME:ChangedProps', ...
                {'NAME:Move Vector', ...
                'X:=','0in', ...
                'Y:=','0in', ...
                'Z:=','deltagap'}}}});
        end

        function defineCurrent(obj)
            obj.oDesign.invoke('ChangeProperty', ...
                {'NAME:AllTabs', ...
                {'NAME:LocalVariableTab', ...
                {'NAME:PropServers','LocalVariables'}, ...
                {'NAME:NewProps', ...
                {'NAME:curr', ...
                'PropType:=','VariableProp', ...
                'UserDef:=',true, ...
                'Value:=',[num2str(obj.turns*obj.ampere),'A']}}}});
            obj.oModule = obj.oDesign.GetModule("BoundarySetup");
            obj.oModule.invoke('EditCurrent', ...
                'Current1', ...
                {'NAME:Current1', ...
                'Current:=','curr', ...
                'IsPositive:=',true});
        end

        function defineSolver(obj,solverName,gapMesh,currMesh) % IMPORTANT
            obj.oModule = obj.oDesign.GetModule("Optimetrics");
            obj.oModule.invoke('InsertSetup', ...
                'OptiParametric', ...
                {['NAME:',solverName], ...
                'IsEnabled:=',true, ...
                {'NAME:ProdOptiSetupDataV2', ...
                'SaveFields:=',true, ...
                'CopyMesh:=',true, ...
                'SolveWithCopiedMeshOnly:=',true}, ...
                {'NAME:StartingPoint'}, ...
                'Sim. Setups:=',{'Setup1'}, ...
                {'NAME:Sweeps', ...
                {'NAME:SweepDefinition', ...
                'Variable:=','deltagap', ...
                'Data:=',sprintf('LIN %s%s %s%s %s%s',num2str(gapMesh(1)),obj.LengthUnit,num2str(gapMesh(2)),obj.LengthUnit,num2str(gapMesh(3)),obj.LengthUnit), ... % 'Data:=','LIN 0in 0.5in 0.05in'
                'OffsetF1:=',false, ...
                'Synchronize:=',0}, ...
                {'NAME:SweepDefinition', ...
                'Variable:=','curr', ...
                'Data:=',sprintf('LINC %sA %sA %s',num2str(currMesh(1)),num2str(currMesh(2)),num2str(currMesh(3))), ... 'Data:=','LINC 0A 1500A 11', % Attention here
                'OffsetF1:=',false, ...
                'Synchronize:=',0}}, ...
                {'NAME:Sweep Operations'}, ...
                {'NAME:Goals', ...
                {'NAME:Goal', ...
                'ReportType:=','Magnetostatic', ...
                'Solution:=','Setup1 : LastAdaptive', ...
                {'NAME:SimValueContext'}, ...
                'Calculation:=','Force1.Force_z', ...
                'Name:=','Force1.Force_z', ...
                {'NAME:Ranges'}}, ...
                {'NAME:Goal', ...
                'ReportType:=','Magnetostatic', ...
                'Solution:=','Setup1 : LastAdaptive', ...
                {'NAME:SimValueContext'}, ...
                'Calculation:=','Matrix1.L(Current1,Current1)', ...
                'Name:=','Matrix1.L(Current1,Current1)' ...
                {'NAME:Ranges'}}}});
            % % Redefining Zero Current Sources
            % % ('it would be a waste of time to solve for a zero solution', but seemingly unnecessary)
            % obj.oModule.invoke('EditSetup',solverName, ...
            % {['NAME:',solverName], ...
            % 'IsEnabled:=',true, ...
            % {'NAME:ProdOptiSetupDataV2', ...
            % 'SaveFields:=',true, ...
            % 'CopyMesh:=',true, ...
            % 'SolveWithCopiedMeshOnly:=',true}, ...
            %  {'NAME:StartingPoint'}, ...
            % 'Sim. Setups:=',{'Setup1'}, ...
            % {'NAME:Sweeps' ...
            % {'NAME:SweepDefinition', ...
            % 'Variable:=','deltagap', ...
            % 'Data:=','LIN 0in 0.5in 0.05in', ... % Attention here
            % 'OffsetF1:=',false, ...
            % 'Synchronize:=',0}, ...
            % {'NAME:SweepDefinition', ...
            % 'Variable:=','curr', ...
            % 'Data:=','LINC 0A 1500A 11', ... % Attention here
            % 'OffsetF1:=',false, ...
            % 'Synchronize:=',0}}, ...
            % {'NAME:Sweep Operations', ...
            % 'edit:=',{'0in','0A','0in','-1A'}, ... % Attention here
            % 'edit:=',{'0.05in','0A','0.05in','-1A'}, ...
            % 'edit:=',{'0.1in','0A','0.1in','-1A'}, ...
            % 'edit:=',{'0.15in','0A','0.15in','-1A'}, ...
            % 'edit:=',{'0.2in','0A','0.2in','-1A'}, ...
            % 'edit:=',{'0.25in','0A','0.25in','-1A'}, ...
            % 'edit:=',{'0.3in','0A','0.3in','-1A'}, ...
            % 'edit:=',{'0.35in','0A','0.35in','-1A'}, ...
            % 'edit:=',{'0.4in','0A','0.4in','-1A'}, ...
            % 'edit:=',{'0.45in','0A','0.45in','-1A'}, ...
            % 'edit:=',{'0.5in','0A','0.5in','-1A'}}, ...
            % {'NAME:Goals', ...
            % {'NAME:Goal', ...
            % 'ReportType:=','Magnetostatic', ...
            % 'Solution:=','Setup1 : LastAdaptive' ...
            % {'NAME:SimValueContext'}, ...
            % 'Calculation:=','Force1.Force_z', ...
            % 'Name:=','Force1.Force_z', ...
            % {'NAME:Ranges'}}, ...
            % {'NAME:Goal', ...
            % 'ReportType:=','Magnetostatic', ...
            % 'Solution:=','Setup1 : LastAdaptive', ...
            % {'NAME:SimValueContext'}, ...
            % 'Calculation:=','Matrix1.L(Current1,Current1)', ...
            % 'Name:=','Matrix1.L(Current1,Current1)' ...
            % {'NAME:Ranges'}}}});
        end

        function exportReports(obj)
            % For force matrix
            obj.oDesign = obj.oProject.SetActiveDesign("Solenoid");
            obj.oModule = obj.oDesign.GetModule("ReportSetup");
            obj.oModule.invoke('CreateReport', ...
                'Force Table 1','Magnetostatic', ...
                'Data Table','Setup1 : LastAdaptive',{}, ...
                {'deltagap:=',{'All'},'curr:=',{'All'}}, ...
                {'X Component:=','deltagap','Y Component:=',{'Force1.Force_z'}});
            forceFileName = fullfile(pwd,obj.FolderName,'Force.csv');
            obj.oModule.ExportToFile('Force Table 1',forceFileName,false);

            % For L matrix
            obj.oModule.invoke('CreateReport',...
                'L Table 1','Magnetostatic',...
                'Data Table','Setup1 : LastAdaptive',{}, ...
                {'deltagap:=',{'All'},'curr:=',{'All'}},...
                {'X Component:=','deltagap','Y Component:=',{'Matrix1.L(Current1,Current1)'}});
            LFileName = fullfile(pwd,obj.FolderName,'L.csv');
            obj.oModule.ExportToFile('L Table 1',LFileName,false);

            % For Magflux matrix
            obj.oModule.invoke('CreateReport',...
                'MagFlux Table 1','Magnetostatic',...
                'Data Table','Setup1 : LastAdaptive',{}, ...
                {'deltagap:=',{'All'}, ...
                'curr:=',{'All'}},...
                {'X Component:=','deltagap', ...
                'Y Component:=',{'Matrix1.MagFlux(Current1)'}});
            MagFluxFileName = fullfile(pwd,obj.FolderName,'MagFlux.csv');
            obj.oModule.ExportToFile('MagFlux Table 1',MagFluxFileName,false);

            forceData = readtable(forceFileName,"VariableNamingRule","preserve");
            LData = readtable(LFileName,"VariableNamingRule","preserve");
            MagFluxData = readtable(MagFluxFileName,"VariableNamingRule","preserve");

            % Obtain units
            % For current
            VarialbeNames = forceData.Properties.VariableNames;
            unitCurrentName = VarialbeNames{1};
            unitCurrentidx = regexpi(unitCurrentName,'\[');
            obj.data.unitCurrent = unitCurrentName(unitCurrentidx+1:end-1);
            % For stroke
            unitStrokeName = VarialbeNames{2};
            unitStrokeidx = regexpi(unitStrokeName,'\[');
            obj.data.unitStroke = unitStrokeName(unitStrokeidx+1:end-1);
            % For force
            unitForceName = VarialbeNames{3};
            unitForceidx = regexpi(unitForceName,'\[');
            obj.data.unitForce = unitForceName(unitForceidx+1:end-1);
            % For L
            VarialbeNames = LData.Properties.VariableNames;
            LName = VarialbeNames{3};
            unitLidx = regexpi(LName,'\[');
            obj.data.unitL = LName(unitLidx+1:end-1);
            % For MagFlux
            VarialbeNames = MagFluxData.Properties.VariableNames;
            MagFluxName = VarialbeNames{3};
            unitMagFluxidx = regexpi(MagFluxName,'\[');
            obj.data.unitMagFlux = MagFluxName(unitMagFluxidx+1:end-1);

            % Obtain raw data
            obj.data.current = table2array(forceData(:,1));
            obj.data.stroke = table2array(forceData(:,2));
            obj.data.force = table2array(forceData(:,3));
            obj.data.L = table2array(LData(:,3));
            obj.data.MagFlux = table2array(MagFluxData(:,3));

            % Obtain current and stroke (vectors)
            obj.data.current_unique = unique(obj.data.current);
            obj.data.stroke_unique = unique(obj.data.stroke);

            % Obtain data matrix
            obj.data.sizeCurrent = numel(obj.data.current_unique);
            obj.data.sizeStroke = numel(obj.data.stroke_unique);
            obj.data.current_m = reshape(obj.data.current,obj.data.sizeStroke,obj.data.sizeCurrent);
            obj.data.stroke_m = reshape(obj.data.stroke,obj.data.sizeStroke,obj.data.sizeCurrent);
            obj.data.force_m = reshape(obj.data.force,obj.data.sizeStroke,obj.data.sizeCurrent);
            obj.data.L_m = reshape(obj.data.L,obj.data.sizeStroke,obj.data.sizeCurrent);
            obj.data.MagFlux_m = reshape(obj.data.MagFlux,obj.data.sizeStroke,obj.data.sizeCurrent);

            % Delete .csv files
            delete(forceFileName);
            delete(LFileName);
            delete(MagFluxFileName);

            % Save results
            results = obj.data;
            save(fullfile(pwd,obj.FolderName,"results.mat"),"results");
        end

        function saveFigure(obj)
            % Save the model figure
            obj.oEditor.ExportModelImageToFile( ...
                fullfile(pwd,"fig.png"),1024,512, ...
                {"NAME:SaveImageParams", ...
                "ShowAxis:=",true, ...
                "ShowGrid:=",true, ...
                "ShowRuler:=",true, ...
                "ShowRegion:=",true, ...
                "Default", ...
                "Selections:=","", ...
                "Orientation:=",""})
        end

        function plotResults(obj)
            file = load(fullfile(pwd,obj.FolderName,"results.mat"));
            figure("Position",[1,41,1920,962])
            tiledlayout(3,4,'TileSpacing','tight')

            % Plot Force
            nexttile
            surf(file.results.current_m,file.results.stroke_m,file.results.force_m,'EdgeColor','none')
            xlabel(sprintf("current (%s)",file.results.unitCurrent))
            ylabel(sprintf("stroke (%s)",file.results.unitStroke))
            zlabel(sprintf("force (%s)",file.results.unitForce))
            title("Electromagnetic force")
            nexttile
            imagesc(file.results.current,file.results.stroke,file.results.force_m)
            xlabel(sprintf("current (%s)",file.results.unitCurrent))
            ylabel(sprintf("stroke (%s)",file.results.unitStroke))
            zlabel(sprintf("force (%s)",file.results.unitForce))
            title("Electromagnetic force")
            colormap("jet")
            colorbar
            set(gca,"YDir","normal")
            nexttile
            hold(gca,"on"),grid(gca,"on"),box(gca,"on")
            for i = 1:file.results.sizeCurrent
                curr = file.results.current_unique(i);
                idx = file.results.current == curr;
                if i == 1 || i == file.results.sizeCurrent
                    plot(file.results.stroke_unique,file.results.force(idx), ...
                        'DisplayName',sprintf('I=%.2f A',curr),'LineWidth',1.5);
                else
                    plot(file.results.stroke_unique,file.results.force(idx), ...
                        'HandleVisibility','off');
                end
            end
            xlabel(sprintf("stroke (%s)",file.results.unitStroke))
            ylabel(sprintf("force (%s)",file.results.unitForce))
            legend()
            title("Electromagnetic force")
            nexttile
            hold(gca,"on"),grid(gca,"on"),box(gca,"on")
            for i = 1:file.results.sizeStroke
                x = file.results.stroke_unique(i);
                idx = file.results.stroke == x;
                if i == 1 || i == file.results.sizeStroke
                    plot(file.results.current_unique,file.results.force(idx), ...
                        'DisplayName',sprintf('x=%.2f %s',x,obj.LengthUnit),'LineWidth',1.5);
                else
                    plot(file.results.current_unique,file.results.force(idx), ...
                        'HandleVisibility','off');
                end
            end
            xlabel(sprintf("current (%s)",file.results.unitCurrent))
            ylabel(sprintf("force (%s)",file.results.unitForce))
            legend()
            title("Electromagnetic force")

            % Plot inductor
            nexttile
            surf(file.results.current_m,file.results.stroke_m,file.results.L_m,'EdgeColor','none')
            xlabel(sprintf("current (%s)",file.results.unitCurrent))
            ylabel(sprintf("stroke (%s)",file.results.unitStroke))
            zlabel(sprintf("L (%s)",file.results.unitL))
            title("Inductor")
            nexttile
            imagesc(file.results.current,file.results.stroke,file.results.L_m)
            xlabel(sprintf("current (%s)",file.results.unitCurrent))
            ylabel(sprintf("stroke (%s)",file.results.unitStroke))
            zlabel(sprintf("L (%s)",file.results.unitL))
            title("Inductor")
            colormap("jet")
            colorbar
            set(gca, "YDir", "normal")
            nexttile
            hold(gca,"on"),grid(gca,"on"),box(gca,"on")
            for i = 1:file.results.sizeCurrent
                curr = file.results.current_unique(i);
                idx = file.results.current == curr;
                if i == 1 || i==file.results.sizeCurrent
                    plot(file.results.stroke_unique,file.results.L(idx), ...
                        'DisplayName',sprintf('I=%.2f A',curr),'LineWidth',1.5);
                else
                    plot(file.results.stroke_unique,file.results.L(idx),'HandleVisibility','off');
                end
            end
            xlabel(sprintf("stroke (%s)",file.results.unitStroke))
            ylabel(sprintf("L (%s)",file.results.unitL))
            legend()
            title("Inductor")
            nexttile
            hold(gca,"on"),grid(gca,"on"),box(gca,"on")
            for i = 1:file.results.sizeStroke
                x = file.results.stroke_unique(i);
                idx = file.results.stroke == x;
                if i == 1 || i == file.results.sizeStroke
                    plot(file.results.current_unique,file.results.L(idx), ...
                        'DisplayName',sprintf('x=%.2f %s',x,obj.LengthUnit),'LineWidth',1.5);
                else
                    plot(file.results.current_unique,file.results.L(idx), ...
                        'HandleVisibility','off');
                end
            end
            xlabel(sprintf("current (%s)",file.results.unitCurrent))
            ylabel(sprintf("L (%s)",file.results.unitL))
            legend()
            title("Inductor")

            % Plot Flux
            nexttile
            surf(file.results.current_m,file.results.stroke_m,file.results.MagFlux_m,'EdgeColor','none')
            xlabel(sprintf("current (%s)",file.results.unitCurrent))
            ylabel(sprintf("stroke (%s)",file.results.unitStroke))
            zlabel(sprintf("Mag Flux (%s)",file.results.unitMagFlux))
            title("Flux")
            nexttile
            imagesc(file.results.current,file.results.stroke,file.results.MagFlux_m)
            xlabel(sprintf("current (%s)",file.results.unitCurrent))
            ylabel(sprintf("stroke (%s)",file.results.unitStroke))
            zlabel(sprintf("Mag Flux (%s)",file.results.unitMagFlux))
            title("Flux")
            colormap("jet")
            colorbar
            set(gca, "YDir", "normal")
            nexttile
            hold(gca,"on"),grid(gca,"on"),box(gca,"on")
            for i = 1:file.results.sizeCurrent
                curr = file.results.current_unique(i);
                idx = file.results.current == curr;
                if i == 1 || i == file.results.sizeCurrent
                    plot(file.results.stroke_unique,file.results.MagFlux(idx), ...
                        'DisplayName',sprintf('I=%.2f A',curr),'LineWidth',1.5);
                else
                    plot(file.results.stroke_unique,file.results.MagFlux(idx), ...
                        'HandleVisibility','off');
                end
            end
            xlabel(sprintf("stroke (%s)",file.results.unitStroke))
            ylabel(sprintf("Mag Flux (%s)",file.results.unitMagFlux))
            legend()
            title("Flux")
            nexttile
            hold(gca,"on"),grid(gca,"on"),box(gca,"on")
            for i = 1:file.results.sizeStroke
                x = file.results.stroke_unique(i);
                idx = file.results.stroke == x;
                if i == 1 || i == file.results.sizeStroke
                    plot(file.results.current_unique,file.results.MagFlux(idx), ...
                        'DisplayName',sprintf('x=%.2f %s',x,obj.LengthUnit),'LineWidth',1.5);
                else
                    plot(file.results.current_unique,file.results.MagFlux(idx), ...
                        'HandleVisibility','off');
                end
            end
            xlabel(sprintf("current (%s)",file.results.unitCurrent))
            ylabel(sprintf("Mag Flux (%s)",file.results.unitMagFlux))
            legend()
            title("Flux")

            % Export figure
            exportgraphics(gcf,fullfile(pwd,obj.FolderName,"results.jpg"),"Resolution",600)
            % % Verify: \Psi=L*I
            % results.L_m*1e-9.*results.current_m-results.MagFlux_m;
        end

        function definePlugnut(obj)
            % Create Plugnut
            obj.oEditor.invoke('CreateRectangle', ...
                {'NAME:RectangleParameters',...
                'IsCovered:=',true,...
                'XStart:=',[num2str(obj.plugnut.XStart),obj.LengthUnit], ...
                'YStart:=','0in', ...
                'ZStart:=',[num2str(obj.plugnut.ZStart),obj.LengthUnit], ...
                'Width:=',[num2str(obj.plugnut.Width),obj.LengthUnit], ...
                'Height:=',[num2str(obj.plugnut.Height),obj.LengthUnit], ...
                'WhichAxis:=','Y'}, ...
                {'NAME:Attributes',...
                'Name:=','Plugnut', ...
                'Flags:=','', ...
                'Color:=','(0 0 255)', ...
                'Transparency:=',0, ...
                'PartCoordinateSystem:=','Global',...
                'UDMId:=','', ...
                'MaterialValue:=','"SS430"', ...
                'SolveInside:=',true, ...
                'ShellElement:=',false,...
                'ShellElementThickness:=','0in',...
                'IsMaterialEditable:=',true, ...
                'UseMaterialAppearance:=',false, ...
                'IsLightweight:=',false
                });
        end

        function defineCore(obj)
            % Create Core
            obj.oEditor.invoke('CreatePolyLine',...
                {'NAME:PolylineParameters',...
                'IsPolylineCovered:=',true, ...
                'IsPolylineClosed:=',true,...
                {'NAME:PolylinePoints', ...
                {'NAME:PLPoint','X:=',[num2str(obj.core.x(1)),obj.LengthUnit],'Y:=','0in','Z:=',[num2str(obj.core.z(1)),obj.LengthUnit]}, ...
                {'NAME:PLPoint','X:=',[num2str(obj.core.x(2)),obj.LengthUnit],'Y:=','0in','Z:=',[num2str(obj.core.z(2)),obj.LengthUnit]}, ...
                {'NAME:PLPoint','X:=',[num2str(obj.core.x(3)),obj.LengthUnit],'Y:=','0in','Z:=',[num2str(obj.core.z(3)),obj.LengthUnit]}, ...
                {'NAME:PLPoint','X:=',[num2str(obj.core.x(4)),obj.LengthUnit],'Y:=','0in','Z:=',[num2str(obj.core.z(4)),obj.LengthUnit]}, ...
                {'NAME:PLPoint','X:=',[num2str(obj.core.x(5)),obj.LengthUnit],'Y:=','0in','Z:=',[num2str(obj.core.z(5)),obj.LengthUnit]}, ...
                {'NAME:PLPoint','X:=',[num2str(obj.core.x(6)),obj.LengthUnit],'Y:=','0in','Z:=',[num2str(obj.core.z(6)),obj.LengthUnit]}, ...
                {'NAME:PLPoint','X:=',[num2str(obj.core.x(7)),obj.LengthUnit],'Y:=','0in','Z:=',[num2str(obj.core.z(7)),obj.LengthUnit]}}, ...
                {'NAME:PolylineSegments',...
                {'NAME:PLSegment','SegmentType:=','Line','StartIndex:=',0,'NoOfPoints:=',2}, ...
                {'NAME:PLSegment','SegmentType:=','Line','StartIndex:=',1,'NoOfPoints:=',2}, ...
                {'NAME:PLSegment','SegmentType:=','Line','StartIndex:=',2,'NoOfPoints:=',2}, ...
                {'NAME:PLSegment','SegmentType:=','Line','StartIndex:=',3,'NoOfPoints:=',2}, ...
                {'NAME:PLSegment','SegmentType:=','Line','StartIndex:=',4,'NoOfPoints:=',2}, ...
                {'NAME:PLSegment','SegmentType:=','Line','StartIndex:=',5,'NoOfPoints:=',2}}, ...
                {'NAME:PolylineXSection', ...
                'XSectionType:=','None', ...
                'XSectionOrient:=','Auto', ...
                'XSectionWidth:=','0in', ...
                'XSectionTopWidth:=','0in', ...
                'XSectionHeight:=','0in', ...
                'XSectionNumSegments:=','0', ...
                'XSectionBendType:=','Corner'}}, ...
                {'NAME:Attributes', ...
                'Name:=', 'Core', ...
                'Flags:=', '', ...
                'Color:=', '(0 255 0)', ...
                'Transparency:=', 0, ...
                'PartCoordinateSystem:=','RelativeCS1', ...
                'UDMId:=', '', ...
                'MaterialValue:=','"Neo35"', ...
                'SurfaceMaterialValue:=', '""', ...
                'SolveInside:=',true, ...
                'ShellElement:=',false, ...
                'ShellElementThickness:=','0in', ...
                'IsMaterialEditable:=',true, ...
                'UseMaterialAppearance:=',false, ...
                'IsLightweight:=', false});
        end

        function defineCoil(obj)
            % Create 'Coil'
            obj.oEditor.invoke('CreateRectangle', ...
                {'NAME:RectangleParameters',...
                'IsCovered:=',true,...
                'XStart:=',[num2str(obj.coil.XStart),obj.LengthUnit], ...
                'YStart:=','0in', ...
                'ZStart:=',[num2str(obj.coil.ZStart),obj.LengthUnit], ...
                'Width:=',[num2str(obj.coil.Width),obj.LengthUnit], ...
                'Height:=',[num2str(obj.coil.Height),obj.LengthUnit], ...
                "WhichAxis:=","Y"}, ...
                {'NAME:Attributes',...
                'Name:=','Coil', ...
                'Flags:=','', ...
                'Color:=','(255 0 0)', ...
                'Transparency:=',0, ...
                'PartCoordinateSystem:=','Global',...
                'UDMId:=','', ...
                'MaterialValue:=','"copper"', ...
                'SolveInside:=',true, ...
                'ShellElement:=',false,...
                'ShellElementThickness:=','0in',...
                'IsMaterialEditable:=',true, ...
                'UseMaterialAppearance:=',false, ...
                'IsLightweight:=',false
                });
        end

        function defineYoke(obj)
            % Create Yoke
            obj.oEditor.invoke('CreatePolyLine',...
                {'NAME:PolylineParameters',...
                'IsPolylineCovered:=',true, ...
                'IsPolylineClosed:=',true,...
                {'NAME:PolylinePoints', ...
                {'NAME:PLPoint','X:=',[num2str(obj.yoke.x(1)),obj.LengthUnit],'Y:=','0in','Z:=',[num2str(obj.yoke.z(1)),obj.LengthUnit]}, ...
                {'NAME:PLPoint','X:=',[num2str(obj.yoke.x(2)),obj.LengthUnit],'Y:=','0in','Z:=',[num2str(obj.yoke.z(2)),obj.LengthUnit]}, ...
                {'NAME:PLPoint','X:=',[num2str(obj.yoke.x(3)),obj.LengthUnit],'Y:=','0in','Z:=',[num2str(obj.yoke.z(3)),obj.LengthUnit]}, ...
                {'NAME:PLPoint','X:=',[num2str(obj.yoke.x(4)),obj.LengthUnit],'Y:=','0in','Z:=',[num2str(obj.yoke.z(4)),obj.LengthUnit]}, ...
                {'NAME:PLPoint','X:=',[num2str(obj.yoke.x(5)),obj.LengthUnit],'Y:=','0in','Z:=',[num2str(obj.yoke.z(5)),obj.LengthUnit]}, ...
                {'NAME:PLPoint','X:=',[num2str(obj.yoke.x(6)),obj.LengthUnit],'Y:=','0in','Z:=',[num2str(obj.yoke.z(6)),obj.LengthUnit]}, ...
                {'NAME:PLPoint','X:=',[num2str(obj.yoke.x(7)),obj.LengthUnit],'Y:=','0in','Z:=',[num2str(obj.yoke.z(7)),obj.LengthUnit]}, ...
                {'NAME:PLPoint','X:=',[num2str(obj.yoke.x(8)),obj.LengthUnit],'Y:=','0in','Z:=',[num2str(obj.yoke.z(8)),obj.LengthUnit]}, ...
                {'NAME:PLPoint','X:=',[num2str(obj.yoke.x(9)),obj.LengthUnit],'Y:=','0in','Z:=',[num2str(obj.yoke.z(9)),obj.LengthUnit]}}, ...
                {'NAME:PolylineSegments',...
                {'NAME:PLSegment','SegmentType:=','Line','StartIndex:=',0,'NoOfPoints:=',2}, ...
                {'NAME:PLSegment','SegmentType:=','Line','StartIndex:=',1,'NoOfPoints:=',2}, ...
                {'NAME:PLSegment','SegmentType:=','Line','StartIndex:=',2,'NoOfPoints:=',2}, ...
                {'NAME:PLSegment','SegmentType:=','Line','StartIndex:=',3,'NoOfPoints:=',2}, ...
                {'NAME:PLSegment','SegmentType:=','Line','StartIndex:=',4,'NoOfPoints:=',2}, ...
                {'NAME:PLSegment','SegmentType:=','Line','StartIndex:=',5,'NoOfPoints:=',2}, ...
                {'NAME:PLSegment','SegmentType:=','Line','StartIndex:=',6,'NoOfPoints:=',2}, ...
                {'NAME:PLSegment','SegmentType:=','Line','StartIndex:=',7,'NoOfPoints:=',2}}, ...
                {'NAME:PolylineXSection', ...
                'XSectionType:=','None', ...
                'XSectionOrient:=','Auto', ...
                'XSectionWidth:=','0in', ...
                'XSectionTopWidth:=','0in', ...
                'XSectionHeight:=','0in', ...
                'XSectionNumSegments:=','0', ...
                'XSectionBendType:=','Corner'}}, ...
                {'NAME:Attributes', ...
                'Name:=','Yoke', ...
                'Flags:=','', ...
                'Color:=','(255 0 255)', ...
                'Transparency:=',0, ...
                'PartCoordinateSystem:=','Global', ...
                'UDMId:=','', ...
                'MaterialValue:=','"ColdRolledSteel"', ...
                'SurfaceMaterialValue:=', '""', ...
                'SolveInside:=',true, ...
                'ShellElement:=',false, ...
                'ShellElementThickness:=','0in', ...
                'IsMaterialEditable:=',true, ...
                'UseMaterialAppearance:=',false, ...
                'IsLightweight:=', false});

        end

        function defineBonnet(obj)
            % Create Bonnet
            obj.oEditor.invoke('CreatePolyLine',...
                {'NAME:PolylineParameters',...
                'IsPolylineCovered:=',true, ...
                'IsPolylineClosed:=',true,...
                {'NAME:PolylinePoints', ...
                {'NAME:PLPoint','X:=',[num2str(obj.bonnet.x(1)),obj.LengthUnit],'Y:=','0in','Z:=',[num2str(obj.bonnet.z(1)),obj.LengthUnit]}, ...
                {'NAME:PLPoint','X:=',[num2str(obj.bonnet.x(2)),obj.LengthUnit],'Y:=','0in','Z:=',[num2str(obj.bonnet.z(2)),obj.LengthUnit]}, ...
                {'NAME:PLPoint','X:=',[num2str(obj.bonnet.x(3)),obj.LengthUnit],'Y:=','0in','Z:=',[num2str(obj.bonnet.z(3)),obj.LengthUnit]}, ...
                {'NAME:PLPoint','X:=',[num2str(obj.bonnet.x(4)),obj.LengthUnit],'Y:=','0in','Z:=',[num2str(obj.bonnet.z(4)),obj.LengthUnit]}, ...
                {'NAME:PLPoint','X:=',[num2str(obj.bonnet.x(5)),obj.LengthUnit],'Y:=','0in','Z:=',[num2str(obj.bonnet.z(5)),obj.LengthUnit]}, ...
                {'NAME:PLPoint','X:=',[num2str(obj.bonnet.x(6)),obj.LengthUnit],'Y:=','0in','Z:=',[num2str(obj.bonnet.z(6)),obj.LengthUnit]}, ...
                {'NAME:PLPoint','X:=',[num2str(obj.bonnet.x(7)),obj.LengthUnit],'Y:=','0in','Z:=',[num2str(obj.bonnet.z(7)),obj.LengthUnit]}}, ...
                {'NAME:PolylineSegments',...
                {'NAME:PLSegment','SegmentType:=','Line','StartIndex:=',0,'NoOfPoints:=',2}, ...
                {'NAME:PLSegment','SegmentType:=','Line','StartIndex:=',1,'NoOfPoints:=',2}, ...
                {'NAME:PLSegment','SegmentType:=','Line','StartIndex:=',2,'NoOfPoints:=',2}, ...
                {'NAME:PLSegment','SegmentType:=','Line','StartIndex:=',3,'NoOfPoints:=',2}, ...
                {'NAME:PLSegment','SegmentType:=','Line','StartIndex:=',4,'NoOfPoints:=',2}, ...
                {'NAME:PLSegment','SegmentType:=','Line','StartIndex:=',5,'NoOfPoints:=',2}}, ...
                {'NAME:PolylineXSection', ...
                'XSectionType:=','None', ...
                'XSectionOrient:=','Auto', ...
                'XSectionWidth:=','0in', ...
                'XSectionTopWidth:=','0in', ...
                'XSectionHeight:=','0in', ...
                'XSectionNumSegments:=','0', ...
                'XSectionBendType:=','Corner'}}, ...
                {'NAME:Attributes', ...
                'Name:=','Bonnet', ...
                'Flags:=','', ...
                'Color:=','(255 255 0)', ...
                'Transparency:=', 0, ...
                'PartCoordinateSystem:=','Global', ...
                'UDMId:=','', ...
                'MaterialValue:=','"ColdRolledSteel"', ...
                'SurfaceMaterialValue:=','""', ...
                'SolveInside:=',true, ...
                'ShellElement:=',false, ...
                'ShellElementThickness:=','0in', ...
                'IsMaterialEditable:=',true, ...
                'UseMaterialAppearance:=',false, ...
                'IsLightweight:=', false});
        end

        function defineBKGD(obj)
            % Create Background
            obj.oEditor.invoke('CreateRectangle', ...
                {'NAME:RectangleParameters',...
                'IsCovered:=',true,...
                'XStart:=',[num2str(obj.bkgd.XStart),obj.LengthUnit], ...
                'YStart:=','0in', ...
                'ZStart:=',[num2str(obj.bkgd.ZStart),obj.LengthUnit], ...
                'Width:=',[num2str(obj.bkgd.Width),obj.LengthUnit], ...
                'Height:=',[num2str(obj.bkgd.Height),obj.LengthUnit], ...
                'WhichAxis:=','Y'}, ...
                {'NAME:Attributes',...
                'Name:=','bgnd', ...
                'Flags:=','', ...
                'Color:=','(143 175 143)', ...
                'Transparency:=',0.9, ...
                'PartCoordinateSystem:=','Global',...
                'UDMId:=','', ...
                'MaterialValue:=','"vacuum"', ...
                'SolveInside:=',true, ...
                'ShellElement:=',false,...
                'ShellElementThickness:=','0in',...
                'IsMaterialEditable:=',true, ...
                'UseMaterialAppearance:=',false, ...
                'IsLightweight:=',false
                });
        end
    end
end
```

Script for instantiating:

```matlab
clc,clear,close all

s = Solenoid();
s.helperPipeline();
```

<br>

# Results

Model diagram in MATLAB:

<img src="https://github.com/HelloWorld-1017/blog-images/blob/main/migration/imgpersonal/image-20230827052906644.png?raw=true" alt="image-20230827052906644" style="zoom: 67%;" />

Matrix data of $F(i,x)$, $L(i,x)$, and $\Phi(i,x)$: 

![image-20230827060053583](https://github.com/HelloWorld-1017/blog-images/blob/main/migration/imgpersonal/image-20230827060053583.png?raw=true)

<br>

**References**

[1] ANSYS Inc, Getting Started with Maxwell: A 2D Magnetostatic Solenoid Problem.

[2] [MATLAB actxserver - MathWorks](https://ww2.mathworks.cn/help/matlab/ref/actxserver.html).

